#include <iomanip>
#include <libwfa/libwfa_exception.h>
#include "cube_writer.h"
#include "export_cube_base.h"


using namespace arma;

namespace libwfa {


const char export_cube_base::k_clazz[] = "export_cube_base";


export_cube_base::export_cube_base(const grid3d &grid,
    const Col<unsigned int> &atnum, const Mat<double> &coords,
    const std::string prefix) :
    m_grid(grid), m_atnum(atnum), m_coords(coords), m_prefix(prefix),
    m_comment("Generated by libwfa"), m_batchsz(grid.size()), m_nmax(0) {

}


void export_cube_base::perform(const std::string &name,
    const std::string &desc, const Mat<double> &data) {

    static const char method[] = "add(const std::string &, "
            "const std::string &, const Mat<double> &)";

    if (data.n_rows != data.n_cols) {
        libwfa_exception(k_clazz, method, __FILE__, __LINE__, "data");
    }
    if (m_dms.find(name) != m_dms.end()) {
        libwfa_exception(k_clazz, method, __FILE__, __LINE__, name.c_str());
    }

    dm_data *ptr = new dm_data(desc, data);
    m_dms.insert(dm_list::value_type(name, ptr));

    if (m_nmax != 0 && m_dms.size() + m_orbs.size() > m_nmax) do_export();
}


void export_cube_base::perform(const std::string &name,
    const std::string &desc, const std::vector<size_t> &idx,
    const Mat<double> &vecs) {

    static const char method[] =
            "add(const std::string &, const std::string &, "
            "const std::vector<size_t> &, const Mat<double> &)";

    if (idx.size() != vecs.n_cols) {
        libwfa_exception(k_clazz, method, __FILE__, __LINE__, "idx");
    }
    if (m_orbs.find(name) != m_orbs.end()) {
        libwfa_exception(k_clazz, method, __FILE__, __LINE__, name.c_str());
    }

    orb_data *ptr = new orb_data(desc, idx, vecs);
    m_orbs.insert(orb_list::value_type(name, ptr));

    if (m_nmax != 0 && m_dms.size() + m_orbs.size() > m_nmax) do_export();
}


void export_cube_base::do_export() {

    typedef std::vector<cube_writer *> cube_writer_list;

    if (m_dms.size() + m_orbs.size() == 0) return;

    // Prepare list of output files for dms
    cube_writer_list dm_writers;
    for (dm_list::iterator i = m_dms.begin(); i != m_dms.end(); i++) {
        std::string fname(m_prefix + i->first + ".cube");
        dm_writers.push_back(new cube_writer(fname, i->second->desc,
                m_comment, m_grid, m_atnum, m_coords));
    }

    // Prepare list of output files for orbitals
    size_t norbs = 0, ndigits = 0, nao = 0;
    if (m_orbs.size() != 0) nao = m_orbs.begin()->second->data.n_rows;
    else nao = m_dms.begin()->second->data.n_rows;
    for (size_t nn = nao; nn > 0; nn /= 10, ndigits++) { ; }

    cube_writer_list orb_writers;
    for (orb_list::iterator i = m_orbs.begin(); i != m_orbs.end(); i++) {

        orb_data &data = *(i->second);
        for (std::vector<size_t>::iterator j = data.idx.begin();
                j != data.idx.end(); j++) {

            std::ostringstream ss1, ss2;
            ss1 << m_prefix << i->first << "." << std::setw(ndigits) <<
                    std::setfill('0') << *j << ".cube";
            ss2 << data.desc << " (orbital " << *j << ")";
            orb_writers.push_back(new cube_writer(ss1.str(), ss2.str(),
                    m_comment, m_grid, m_atnum, m_coords));
        }
    }

    // Now perform the loop over the batches
    Mat<double> pts(3, m_batchsz, fill::zeros);
    Mat<double> b2g(m_batchsz, nao, fill::zeros);

    size_t ipts = 0;
    while (ipts < m_grid.size()) {

        // 1) Build grid points
        ipts += m_grid.build_pts(ipts, pts);

        // 2) Evaluate basis functions on grid points
        evaluate_on_grid(pts, b2g);

        // 3) Loop over density matrix data
        cube_writer_list::iterator id = dm_writers.begin();
        for (dm_list::iterator i = m_dms.begin();
                i != m_dms.end(); i++, id++) {

            Col<double> data = diagvec(b2g * i->second->data * b2g.t());
            (*id)->write(data);
        }

        // 4) Loop over orbital data
        cube_writer_list::iterator io = orb_writers.begin();
        for (orb_list::iterator i = m_orbs.begin();
                i != m_orbs.end(); i++) {

            Mat<double> data = b2g * i->second->data;
            for (size_t j = 0; j < data.n_cols; j++, io++)
                (*io)->write(data.col(j));
        }
    }

    // Delete cube writers and close files
    for (cube_writer_list::iterator i = dm_writers.begin();
            i != dm_writers.end(); i++) {
        delete *i; *i = 0;
    }
    dm_writers.clear();

    for (cube_writer_list::iterator i = orb_writers.begin();
            i != orb_writers.end(); i++) {
        delete *i; *i = 0;
    }
    orb_writers.clear();

    // Delete density matrix data and orbital data
    clear_data();
}


void export_cube_base::clear_data() {

    for (dm_list::iterator i = m_dms.begin(); i != m_dms.end(); i++) {
        delete i->second; i->second = 0;
    }
    m_dms.clear();

    for (orb_list::iterator i = m_orbs.begin(); i != m_orbs.end(); i++) {
        delete i->second; i->second = 0;
    }
    m_orbs.clear();
}


} // namespace libwfa



